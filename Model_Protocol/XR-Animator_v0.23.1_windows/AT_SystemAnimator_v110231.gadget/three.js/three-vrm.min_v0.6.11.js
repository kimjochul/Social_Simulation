(function(e,n){typeof exports==="object"&&typeof module!=="undefined"?n(exports,require("three")):typeof define==="function"&&define.amd?define(["exports","three"],n):(e=typeof globalThis!=="undefined"?globalThis:e||self,n(e.THREE_VRM={},e.THREE))})(this,function(u,_){"use strict";function N(t){if(t&&t.__esModule)return t;var i=Object.create(null);if(t){Object.keys(t).forEach(function(e){if(e!=="default"){var n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(i,e,n.get?n:{enumerable:true,get:function(){return t[e]}})}})}i["default"]=t;return Object.freeze(i)}var v=N(_);function f(e,s,t,a){function l(n){return n instanceof t?n:new t(function(e){e(n)})}return new(t||(t=Promise))(function(n,t){function i(e){try{o(a.next(e))}catch(n){t(n)}}function r(e){try{o(a["throw"](e))}catch(n){t(n)}}function o(e){e.done?n(e.value):l(e.value).then(i,r)}o((a=a.apply(e,s||[])).next())})}function i(i){Object.keys(i).forEach(e=>{const n=i[e];if(n===null||n===void 0?void 0:n.isTexture){const t=n;t.dispose()}});i.dispose()}function U(e){const n=e.geometry;if(n){n.dispose()}const t=e.material;if(t){if(Array.isArray(t)){t.forEach(e=>i(e))}else if(t){i(t)}}}function B(e){e.traverse(U)}var l;(function(e){e[e["NUMBER"]=0]="NUMBER";e[e["VECTOR2"]=1]="VECTOR2";e[e["VECTOR3"]=2]="VECTOR3";e[e["VECTOR4"]=3]="VECTOR4";e[e["COLOR"]=4]="COLOR"})(l||(l={}));const G=new v.Vector2;const H=new v.Vector3;const k=new v.Vector4;const F=new v.Color;class d extends v.Object3D{constructor(e){super();this.weight=0;this.isBinary=false;this._binds=[];this._materialValues=[];this.name=`BlendShapeController_${e}`;this.type="BlendShapeController";this.visible=false}addBind(e){const n=e.weight/100;this._binds.push({meshes:e.meshes,morphTargetIndex:e.morphTargetIndex,weight:n})}addMaterialValue(e){const n=e.material;const t=e.propertyName;let i=n[t];if(!i){return}i=e.defaultValue||i;let r;let o;let s;let a;if(i.isVector2){r=l.VECTOR2;o=i.clone();s=(new v.Vector2).fromArray(e.targetValue);a=s.clone().sub(o)}else if(i.isVector3){r=l.VECTOR3;o=i.clone();s=(new v.Vector3).fromArray(e.targetValue);a=s.clone().sub(o)}else if(i.isVector4){r=l.VECTOR4;o=i.clone();s=(new v.Vector4).fromArray([e.targetValue[2],e.targetValue[3],e.targetValue[0],e.targetValue[1]]);a=s.clone().sub(o)}else if(i.isColor){r=l.COLOR;o=i.clone();s=(new v.Color).fromArray(e.targetValue);a=s.clone().sub(o)}else{r=l.NUMBER;o=i;s=e.targetValue[0];a=s-o}this._materialValues.push({material:n,propertyName:t,defaultValue:o,targetValue:s,deltaValue:a,type:r})}applyWeight(){const i=this.isBinary?this.weight<.5?0:1:this.weight;this._binds.forEach(n=>{n.meshes.forEach(e=>{if(!e.morphTargetInfluences){return}e.morphTargetInfluences[n.morphTargetIndex]+=i*n.weight})});this._materialValues.forEach(e=>{const n=e.material[e.propertyName];if(n===undefined){return}if(e.type===l.NUMBER){const t=e.deltaValue;e.material[e.propertyName]+=t*i}else if(e.type===l.VECTOR2){const t=e.deltaValue;e.material[e.propertyName].add(G.copy(t).multiplyScalar(i))}else if(e.type===l.VECTOR3){const t=e.deltaValue;e.material[e.propertyName].add(H.copy(t).multiplyScalar(i))}else if(e.type===l.VECTOR4){const t=e.deltaValue;e.material[e.propertyName].add(k.copy(t).multiplyScalar(i))}else if(e.type===l.COLOR){const t=e.deltaValue;e.material[e.propertyName].add(F.copy(t).multiplyScalar(i))}if(typeof e.material.shouldApplyUniforms==="boolean"){e.material.shouldApplyUniforms=true}})}clearAppliedWeight(){this._binds.forEach(n=>{n.meshes.forEach(e=>{if(!e.morphTargetInfluences){return}e.morphTargetInfluences[n.morphTargetIndex]=0})});this._materialValues.forEach(e=>{const n=e.material[e.propertyName];if(n===undefined){return}if(e.type===l.NUMBER){const t=e.defaultValue;e.material[e.propertyName]=t}else if(e.type===l.VECTOR2){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===l.VECTOR3){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===l.VECTOR4){const t=e.defaultValue;e.material[e.propertyName].copy(t)}else if(e.type===l.COLOR){const t=e.defaultValue;e.material[e.propertyName].copy(t)}if(typeof e.material.shouldApplyUniforms==="boolean"){e.material.shouldApplyUniforms=true}})}}u.VRMSchema=void 0;(function(e){(function(e){e["A"]="a";e["Angry"]="angry";e["Blink"]="blink";e["BlinkL"]="blink_l";e["BlinkR"]="blink_r";e["E"]="e";e["Fun"]="fun";e["I"]="i";e["Joy"]="joy";e["Lookdown"]="lookdown";e["Lookleft"]="lookleft";e["Lookright"]="lookright";e["Lookup"]="lookup";e["Neutral"]="neutral";e["O"]="o";e["Sorrow"]="sorrow";e["U"]="u";e["Unknown"]="unknown"})(e.BlendShapePresetName||(e.BlendShapePresetName={}));(function(e){e["BlendShape"]="BlendShape";e["Bone"]="Bone"})(e.FirstPersonLookAtTypeName||(e.FirstPersonLookAtTypeName={}));(function(e){e["Chest"]="chest";e["Head"]="head";e["Hips"]="hips";e["Jaw"]="jaw";e["LeftEye"]="leftEye";e["LeftFoot"]="leftFoot";e["LeftHand"]="leftHand";e["LeftIndexDistal"]="leftIndexDistal";e["LeftIndexIntermediate"]="leftIndexIntermediate";e["LeftIndexProximal"]="leftIndexProximal";e["LeftLittleDistal"]="leftLittleDistal";e["LeftLittleIntermediate"]="leftLittleIntermediate";e["LeftLittleProximal"]="leftLittleProximal";e["LeftLowerArm"]="leftLowerArm";e["LeftLowerLeg"]="leftLowerLeg";e["LeftMiddleDistal"]="leftMiddleDistal";e["LeftMiddleIntermediate"]="leftMiddleIntermediate";e["LeftMiddleProximal"]="leftMiddleProximal";e["LeftRingDistal"]="leftRingDistal";e["LeftRingIntermediate"]="leftRingIntermediate";e["LeftRingProximal"]="leftRingProximal";e["LeftShoulder"]="leftShoulder";e["LeftThumbDistal"]="leftThumbDistal";e["LeftThumbIntermediate"]="leftThumbIntermediate";e["LeftThumbProximal"]="leftThumbProximal";e["LeftToes"]="leftToes";e["LeftUpperArm"]="leftUpperArm";e["LeftUpperLeg"]="leftUpperLeg";e["Neck"]="neck";e["RightEye"]="rightEye";e["RightFoot"]="rightFoot";e["RightHand"]="rightHand";e["RightIndexDistal"]="rightIndexDistal";e["RightIndexIntermediate"]="rightIndexIntermediate";e["RightIndexProximal"]="rightIndexProximal";e["RightLittleDistal"]="rightLittleDistal";e["RightLittleIntermediate"]="rightLittleIntermediate";e["RightLittleProximal"]="rightLittleProximal";e["RightLowerArm"]="rightLowerArm";e["RightLowerLeg"]="rightLowerLeg";e["RightMiddleDistal"]="rightMiddleDistal";e["RightMiddleIntermediate"]="rightMiddleIntermediate";e["RightMiddleProximal"]="rightMiddleProximal";e["RightRingDistal"]="rightRingDistal";e["RightRingIntermediate"]="rightRingIntermediate";e["RightRingProximal"]="rightRingProximal";e["RightShoulder"]="rightShoulder";e["RightThumbDistal"]="rightThumbDistal";e["RightThumbIntermediate"]="rightThumbIntermediate";e["RightThumbProximal"]="rightThumbProximal";e["RightToes"]="rightToes";e["RightUpperArm"]="rightUpperArm";e["RightUpperLeg"]="rightUpperLeg";e["Spine"]="spine";e["UpperChest"]="upperChest"})(e.HumanoidBoneName||(e.HumanoidBoneName={}));(function(e){e["Everyone"]="Everyone";e["ExplicitlyLicensedPerson"]="ExplicitlyLicensedPerson";e["OnlyAuthor"]="OnlyAuthor"})(e.MetaAllowedUserName||(e.MetaAllowedUserName={}));(function(e){e["Allow"]="Allow";e["Disallow"]="Disallow"})(e.MetaUssageName||(e.MetaUssageName={}));(function(e){e["Cc0"]="CC0";e["CcBy"]="CC_BY";e["CcByNc"]="CC_BY_NC";e["CcByNcNd"]="CC_BY_NC_ND";e["CcByNcSa"]="CC_BY_NC_SA";e["CcByNd"]="CC_BY_ND";e["CcBySa"]="CC_BY_SA";e["Other"]="Other";e["RedistributionProhibited"]="Redistribution_Prohibited"})(e.MetaLicenseName||(e.MetaLicenseName={}))})(u.VRMSchema||(u.VRMSchema={}));function o(e,n,t){const i=e.parser.json.nodes[n];const r=i.mesh;if(r==null){return null}const o=e.parser.json.meshes[r];const s=o.primitives.length;const a=[];t.traverse(e=>{if(a.length<s){if(e.isMesh){a.push(e)}}});return a}function W(n,t){return f(this,void 0,void 0,function*(){const e=yield n.parser.getDependency("node",t);return o(n,t,e)})}function p(r){return f(this,void 0,void 0,function*(){const e=yield r.parser.getDependencies("node");const i=new Map;e.forEach((e,n)=>{const t=o(r,n,e);if(t!=null){i.set(n,t)}});return i})}function z(e){if(e[0]!=="_"){console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`);return e}e=e.substring(1);if(!/[A-Z]/.test(e[0])){console.warn(`renameMaterialProperty: Given property name "${e}" might be invalid`);return e}return e[0].toLowerCase()+e.substring(1)}function j(e){return Math.max(Math.min(e,1),0)}const Y=new v.Vector3;const X=new v.Vector3;new v.Quaternion;function s(e,n){e.matrixWorld.decompose(Y,n,X);return n}class q{constructor(){this._blendShapeGroups={};this._blendShapePresetMap={};this._unknownGroupNames=[]}get expressions(){return Object.keys(this._blendShapeGroups)}get blendShapePresetMap(){return this._blendShapePresetMap}get unknownGroupNames(){return this._unknownGroupNames}getBlendShapeGroup(e){const n=this._blendShapePresetMap[e];const t=n?this._blendShapeGroups[n]:this._blendShapeGroups[e];if(!t){console.warn(`no blend shape found by ${e}`);return undefined}return t}registerBlendShapeGroup(e,n,t){this._blendShapeGroups[e]=t;if(n){this._blendShapePresetMap[n]=e}else{this._unknownGroupNames.push(e)}}getValue(e){var n;const t=this.getBlendShapeGroup(e);return(n=t===null||t===void 0?void 0:t.weight)!==null&&n!==void 0?n:null}setValue(e,n){const t=this.getBlendShapeGroup(e);if(t){t.weight=j(n)}}getBlendShapeTrackName(e){const n=this.getBlendShapeGroup(e);return n?`${n.name}.weight`:null}update(){Object.keys(this._blendShapeGroups).forEach(e=>{const n=this._blendShapeGroups[e];n.clearAppliedWeight()});Object.keys(this._blendShapeGroups).forEach(e=>{const n=this._blendShapeGroups[e];n.applyWeight()})}}class Q{"import"(a){var o;return f(this,void 0,void 0,function*(){const e=(o=a.parser.json.extensions)===null||o===void 0?void 0:o.VRM;if(!e){return null}const n=e.blendShapeMaster;if(!n){return null}const i=new q;const t=n.blendShapeGroups;if(!t){return i}const r={};yield Promise.all(t.map(s=>f(this,void 0,void 0,function*(){const e=s.name;if(e===undefined){console.warn("VRMBlendShapeImporter: One of blendShapeGroups has no name");return}let n;if(s.presetName&&s.presetName!==u.VRMSchema.BlendShapePresetName.Unknown&&!r[s.presetName]){n=s.presetName;r[s.presetName]=e}const o=new d(e);a.scene.add(o);o.isBinary=s.isBinary||false;if(s.binds){s.binds.forEach(r=>f(this,void 0,void 0,function*(){if(r.mesh===undefined||r.index===undefined){return}const t=[];a.parser.json.nodes.forEach((e,n)=>{if(e.mesh===r.mesh){t.push(n)}});const i=r.index;yield Promise.all(t.map(t=>f(this,void 0,void 0,function*(){var e;const n=yield W(a,t);if(!n.every(e=>Array.isArray(e.morphTargetInfluences)&&i<e.morphTargetInfluences.length)){console.warn(`VRMBlendShapeImporter: ${s.name} attempts to index ${i}th morph but not found.`);return}o.addBind({meshes:n,morphTargetIndex:i,weight:(e=r.weight)!==null&&e!==void 0?e:100})})))}))}const t=s.materialValues;if(t){t.forEach(t=>{if(t.materialName===undefined||t.propertyName===undefined||t.targetValue===undefined){return}const i=[];a.scene.traverse(e=>{if(e.material){const n=e.material;if(Array.isArray(n)){i.push(...n.filter(e=>e.name===t.materialName&&i.indexOf(e)===-1))}else if(n.name===t.materialName&&i.indexOf(n)===-1){i.push(n)}}});i.forEach(e=>{o.addMaterialValue({material:e,propertyName:z(t.propertyName),targetValue:t.targetValue})})})}i.registerBlendShapeGroup(e,n,o)})));return i})}}const Z=Object.freeze(new v.Vector3(0,0,-1));const $=new v.Quaternion;var t;(function(e){e[e["Auto"]=0]="Auto";e[e["Both"]=1]="Both";e[e["ThirdPersonOnly"]=2]="ThirdPersonOnly";e[e["FirstPersonOnly"]=3]="FirstPersonOnly"})(t||(t={}));class h{constructor(e,n){this.firstPersonFlag=h._parseFirstPersonFlag(e);this.primitives=n}static _parseFirstPersonFlag(e){switch(e){case"Both":return t.Both;case"ThirdPersonOnly":return t.ThirdPersonOnly;case"FirstPersonOnly":return t.FirstPersonOnly;default:return t.Auto}}}class c{constructor(e,n,t){this._meshAnnotations=[];this._firstPersonOnlyLayer=c._DEFAULT_FIRSTPERSON_ONLY_LAYER;this._thirdPersonOnlyLayer=c._DEFAULT_THIRDPERSON_ONLY_LAYER;this._initialized=false;this._firstPersonBone=e;this._firstPersonBoneOffset=n;this._meshAnnotations=t}get firstPersonBone(){return this._firstPersonBone}get meshAnnotations(){return this._meshAnnotations}getFirstPersonWorldDirection(e){return e.copy(Z).applyQuaternion(s(this._firstPersonBone,$))}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}getFirstPersonBoneOffset(e){return e.copy(this._firstPersonBoneOffset)}getFirstPersonWorldPosition(e){const n=this._firstPersonBoneOffset;const t=new v.Vector4(n.x,n.y,n.z,1);t.applyMatrix4(this._firstPersonBone.matrixWorld);return e.set(t.x,t.y,t.z)}setup({firstPersonOnlyLayer:e=c._DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:n=c._DEFAULT_THIRDPERSON_ONLY_LAYER}={}){if(this._initialized){return}this._initialized=true;this._firstPersonOnlyLayer=e;this._thirdPersonOnlyLayer=n;this._meshAnnotations.forEach(e=>{if(e.firstPersonFlag===t.FirstPersonOnly){e.primitives.forEach(e=>{e.layers.set(this._firstPersonOnlyLayer)})}else if(e.firstPersonFlag===t.ThirdPersonOnly){e.primitives.forEach(e=>{e.layers.set(this._thirdPersonOnlyLayer)})}else if(e.firstPersonFlag===t.Auto){this._createHeadlessModel(e.primitives)}})}_excludeTriangles(n,t,i,r){let o=0;if(t!=null&&t.length>0){for(let e=0;e<n.length;e+=3){const s=n[e];const a=n[e+1];const l=n[e+2];const d=t[s];const u=i[s];if(d[0]>0&&r.includes(u[0]))continue;if(d[1]>0&&r.includes(u[1]))continue;if(d[2]>0&&r.includes(u[2]))continue;if(d[3]>0&&r.includes(u[3]))continue;const h=t[a];const c=i[a];if(h[0]>0&&r.includes(c[0]))continue;if(h[1]>0&&r.includes(c[1]))continue;if(h[2]>0&&r.includes(c[2]))continue;if(h[3]>0&&r.includes(c[3]))continue;const f=t[l];const p=i[l];if(f[0]>0&&r.includes(p[0]))continue;if(f[1]>0&&r.includes(p[1]))continue;if(f[2]>0&&r.includes(p[2]))continue;if(f[3]>0&&r.includes(p[3]))continue;n[o++]=s;n[o++]=a;n[o++]=l}}return o}_createErasedMesh(e,n){const t=new v.SkinnedMesh(e.geometry.clone(),e.material);t.name=`${e.name}(erase)`;t.frustumCulled=e.frustumCulled;t.layers.set(this._firstPersonOnlyLayer);const i=t.geometry;const r=i.getAttribute("skinIndex").array;const o=[];for(let e=0;e<r.length;e+=4){o.push([r[e],r[e+1],r[e+2],r[e+3]])}const s=i.getAttribute("skinWeight").array;const a=[];for(let e=0;e<s.length;e+=4){a.push([s[e],s[e+1],s[e+2],s[e+3]])}const l=i.getIndex();if(!l){throw new Error("The geometry doesn't have an index buffer")}const d=Array.from(l.array);const u=this._excludeTriangles(d,a,o,n);const h=[];for(let e=0;e<u;e++){h[e]=d[e]}i.setIndex(h);if(e.onBeforeRender){t.onBeforeRender=e.onBeforeRender}t.bind(new v.Skeleton(e.skeleton.bones,e.skeleton.boneInverses),new v.Matrix4);return t}_createHeadlessModelForSkinnedMesh(e,n){const t=[];n.skeleton.bones.forEach((e,n)=>{if(this._isEraseTarget(e))t.push(n)});if(!t.length){n.layers.enable(this._thirdPersonOnlyLayer);n.layers.enable(this._firstPersonOnlyLayer);return}n.layers.set(this._thirdPersonOnlyLayer);const i=this._createErasedMesh(n,t);e.add(i)}_createHeadlessModel(e){e.forEach(e=>{if(e.type==="SkinnedMesh"){const n=e;this._createHeadlessModelForSkinnedMesh(n.parent,n)}else{if(this._isEraseTarget(e)){e.layers.set(this._thirdPersonOnlyLayer)}}})}_isEraseTarget(e){if(e===this._firstPersonBone){return true}else if(!e.parent){return false}else{return this._isEraseTarget(e.parent)}}}c._DEFAULT_FIRSTPERSON_ONLY_LAYER=9;c._DEFAULT_THIRDPERSON_ONLY_LAYER=10;class J{"import"(a,l){var d;return f(this,void 0,void 0,function*(){const e=(d=a.parser.json.extensions)===null||d===void 0?void 0:d.VRM;if(!e){return null}const r=e.firstPerson;if(!r){return null}const n=r.firstPersonBone;let t;if(n===undefined||n===-1){t=l.getBoneNode(u.VRMSchema.HumanoidBoneName.Head)}else{t=yield a.parser.getDependency("node",n)}if(!t){console.warn("VRMFirstPersonImporter: Could not find firstPersonBone of the VRM");return null}const i=r.firstPersonBoneOffset?new v.Vector3(r.firstPersonBoneOffset.x,r.firstPersonBoneOffset.y,-r.firstPersonBoneOffset.z):new v.Vector3(0,.06,0);const o=[];const s=yield p(a);Array.from(s.entries()).forEach(([e,n])=>{const t=a.parser.json.nodes[e];const i=r.meshAnnotations?r.meshAnnotations.find(e=>e.mesh===t.mesh):undefined;o.push(new h(i===null||i===void 0?void 0:i.firstPersonFlag,n))});return new c(t,i,o)})}}class K{constructor(e,n){this.node=e;this.humanLimit=n}}function ee(e){if(e.invert){e.invert()}else{e.inverse()}return e}const a=new v.Vector3;const m=new v.Quaternion;class ne{constructor(e,n){this.restPose={};this.humanBones=this._createHumanBones(e);this.humanDescription=n;this.restPose=this.getPose()}getPose(){const i={};Object.keys(this.humanBones).forEach(e=>{const n=this.getBoneNode(e);if(!n){return}if(i[e]){return}a.set(0,0,0);m.identity();const t=this.restPose[e];if(t===null||t===void 0?void 0:t.position){a.fromArray(t.position).negate()}if(t===null||t===void 0?void 0:t.rotation){ee(m.fromArray(t.rotation))}a.add(n.position);m.premultiply(n.quaternion);i[e]={position:a.toArray(),rotation:m.toArray()}},{});return i}setPose(r){Object.keys(r).forEach(e=>{const n=r[e];const t=this.getBoneNode(e);if(!t){return}const i=this.restPose[e];if(!i){return}if(n.position){t.position.fromArray(n.position);if(i.position){t.position.add(a.fromArray(i.position))}}if(n.rotation){t.quaternion.fromArray(n.rotation);if(i.rotation){t.quaternion.multiply(m.fromArray(i.rotation))}}})}resetPose(){Object.entries(this.restPose).forEach(([e,n])=>{const t=this.getBoneNode(e);if(!t){return}if(n===null||n===void 0?void 0:n.position){t.position.fromArray(n.position)}if(n===null||n===void 0?void 0:n.rotation){t.quaternion.fromArray(n.rotation)}})}getBone(e){var n;return(n=this.humanBones[e][0])!==null&&n!==void 0?n:undefined}getBones(e){var n;return(n=this.humanBones[e])!==null&&n!==void 0?n:[]}getBoneNode(e){var n,t;return(t=(n=this.humanBones[e][0])===null||n===void 0?void 0:n.node)!==null&&t!==void 0?t:null}getBoneNodes(e){var n,t;return(t=(n=this.humanBones[e])===null||n===void 0?void 0:n.map(e=>e.node))!==null&&t!==void 0?t:[]}_createHumanBones(e){const n=Object.values(u.VRMSchema.HumanoidBoneName).reduce((e,n)=>{e[n]=[];return e},{});e.forEach(e=>{n[e.name].push(e.bone)});return n}}class te{"import"(r){var o;return f(this,void 0,void 0,function*(){const e=(o=r.parser.json.extensions)===null||o===void 0?void 0:o.VRM;if(!e){return null}const n=e.humanoid;if(!n){return null}const t=[];if(n.humanBones){yield Promise.all(n.humanBones.map(n=>f(this,void 0,void 0,function*(){if(!n.bone||n.node==null){return}const e=yield r.parser.getDependency("node",n.node);t.push({name:n.bone,bone:new K(e,{axisLength:n.axisLength,center:n.center&&new v.Vector3(n.center.x,n.center.y,n.center.z),max:n.max&&new v.Vector3(n.max.x,n.max.y,n.max.z),min:n.min&&new v.Vector3(n.min.x,n.min.y,n.min.z),useDefaultValues:n.useDefaultValues})})})))}const i={armStretch:n.armStretch,legStretch:n.legStretch,upperArmTwist:n.upperArmTwist,lowerArmTwist:n.lowerArmTwist,upperLegTwist:n.upperLegTwist,lowerLegTwist:n.lowerLegTwist,feetSpacing:n.feetSpacing,hasTranslationDoF:n.hasTranslationDoF};return new ne(t,i)})}}const ie=(e,n,t,i,r)=>{const o=r*r*r;const s=r*r;const a=n-e;const l=-2*o+3*s;const d=o-2*s+r;const u=o-s;return e+a*l+t*d+i*u};const re=(e,n)=>{if(e.length<8){throw new Error("evaluateCurve: Invalid curve detected! (Array length must be 8 at least)")}if(e.length%4!==0){throw new Error("evaluateCurve: Invalid curve detected! (Array length must be multiples of 4")}let t;for(t=0;;t++){if(e.length<=4*t){return e[4*t-3]}else if(n<=e[4*t]){break}}const i=t-1;if(i<0){return e[4*i+5]}const r=e[4*i];const o=e[4*t];const s=(n-r)/(o-r);const a=e[4*i+1];const l=e[4*t+1];const d=e[4*i+3];const u=e[4*t+2];return ie(a,l,d,u,s)};class n{constructor(e,n,t){this.curve=[0,0,0,1,1,1,1,0];this.curveXRangeDegree=90;this.curveYRangeDegree=10;if(e!==undefined){this.curveXRangeDegree=e}if(n!==undefined){this.curveYRangeDegree=n}if(t!==undefined){this.curve=t}}map(e){const n=Math.min(Math.max(e,0),this.curveXRangeDegree);const t=n/this.curveXRangeDegree;return this.curveYRangeDegree*re(this.curve,t)}}class e{}class oe extends e{constructor(e,n,t,i){super();this.type=u.VRMSchema.FirstPersonLookAtTypeName.BlendShape;this._curveHorizontal=n;this._curveVerticalDown=t;this._curveVerticalUp=i;this._blendShapeProxy=e}name(){return u.VRMSchema.FirstPersonLookAtTypeName.BlendShape}lookAt(e){const n=e.x;const t=e.y;if(n<0){this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookup,0);this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookdown,this._curveVerticalDown.map(-n))}else{this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookdown,0);this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookup,this._curveVerticalUp.map(n))}if(t<0){this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookleft,0);this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookright,this._curveHorizontal.map(-t))}else{this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookright,0);this._blendShapeProxy.setValue(u.VRMSchema.BlendShapePresetName.Lookleft,this._curveHorizontal.map(t))}}}const se=Object.freeze(new v.Vector3(0,0,-1));const ae=new v.Vector3;const le=new v.Vector3;const de=new v.Vector3;const ue=new v.Quaternion;class g{constructor(e,n){this.autoUpdate=true;this._euler=new v.Euler(0,0,0,g.EULER_ORDER);this.firstPerson=e;this.applyer=n}getLookAtWorldDirection(e){const n=s(this.firstPerson.firstPersonBone,ue);return e.copy(se).applyEuler(this._euler).applyQuaternion(n)}lookAt(e){this._calcEuler(this._euler,e);if(this.applyer){this.applyer.lookAt(this._euler)}}update(e){if(this.target&&this.autoUpdate){this.lookAt(this.target.getWorldPosition(ae));if(this.applyer){this.applyer.lookAt(this._euler)}}}_calcEuler(e,n){const t=this.firstPerson.getFirstPersonWorldPosition(le);const i=de.copy(n).sub(t).normalize();i.applyQuaternion(ee(s(this.firstPerson.firstPersonBone,ue)));e.x=Math.atan2(i.y,Math.sqrt(i.x*i.x+i.z*i.z));e.y=Math.atan2(-i.x,-i.z);return e}}g.EULER_ORDER="YXZ";const r=new v.Euler(0,0,0,g.EULER_ORDER);class he extends e{constructor(e,n,t,i,r){super();this.type=u.VRMSchema.FirstPersonLookAtTypeName.Bone;this._curveHorizontalInner=n;this._curveHorizontalOuter=t;this._curveVerticalDown=i;this._curveVerticalUp=r;this._leftEye=e.getBoneNode(u.VRMSchema.HumanoidBoneName.LeftEye);this._rightEye=e.getBoneNode(u.VRMSchema.HumanoidBoneName.RightEye)}lookAt(e){const n=e.x;const t=e.y;if(this._leftEye){if(n<0){r.x=-this._curveVerticalDown.map(-n)}else{r.x=this._curveVerticalUp.map(n)}if(t<0){r.y=-this._curveHorizontalInner.map(-t)}else{r.y=this._curveHorizontalOuter.map(t)}this._leftEye.quaternion.setFromEuler(r)}if(this._rightEye){if(n<0){r.x=-this._curveVerticalDown.map(-n)}else{r.x=this._curveVerticalUp.map(n)}if(t<0){r.y=-this._curveHorizontalOuter.map(-t)}else{r.y=this._curveHorizontalInner.map(t)}this._rightEye.quaternion.setFromEuler(r)}}}const M=Math.PI/180;class T{"import"(e,n,t,i){var r;const o=(r=e.parser.json.extensions)===null||r===void 0?void 0:r.VRM;if(!o){return null}const s=o.firstPerson;if(!s){return null}const a=this._importApplyer(s,t,i);return new g(n,a||undefined)}_importApplyer(e,n,t){const i=e.lookAtHorizontalInner;const r=e.lookAtHorizontalOuter;const o=e.lookAtVerticalDown;const s=e.lookAtVerticalUp;switch(e.lookAtTypeName){case u.VRMSchema.FirstPersonLookAtTypeName.Bone:{if(i===undefined||r===undefined||o===undefined||s===undefined){return null}else{return new he(t,this._importCurveMapperBone(i),this._importCurveMapperBone(r),this._importCurveMapperBone(o),this._importCurveMapperBone(s))}}case u.VRMSchema.FirstPersonLookAtTypeName.BlendShape:{if(r===undefined||o===undefined||s===undefined){return null}else{return new oe(n,this._importCurveMapperBlendShape(r),this._importCurveMapperBlendShape(o),this._importCurveMapperBlendShape(s))}}default:{return null}}}_importCurveMapperBone(e){return new n(typeof e.xRange==="number"?M*e.xRange:undefined,typeof e.yRange==="number"?M*e.yRange:undefined,e.curve)}_importCurveMapperBlendShape(e){return new n(typeof e.xRange==="number"?M*e.xRange:undefined,e.yRange,e.curve)}}var ce="// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  #ifdef MTOON_UVS_VERTEX_ONLY\n    vec2 vUv;\n  #else\n    varying vec2 vUv;\n  #endif\n\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHTEXTURE\n  uniform sampler2D outlineWidthTexture;\n#endif\n\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    vUv = uv;\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHTEXTURE\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}";var fe='// #define PHONG\n\n#ifdef BLENDMODE_CUTOUT\n  uniform float cutoff;\n#endif\n\nuniform vec3 color;\nuniform float colorAlpha;\nuniform vec3 shadeColor;\n#ifdef USE_SHADETEXTURE\n  uniform sampler2D shadeTexture;\n#endif\n\nuniform float receiveShadowRate;\n#ifdef USE_RECEIVESHADOWTEXTURE\n  uniform sampler2D receiveShadowTexture;\n#endif\n\nuniform float shadingGradeRate;\n#ifdef USE_SHADINGGRADETEXTURE\n  uniform sampler2D shadingGradeTexture;\n#endif\n\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\n\n#ifdef USE_RIMTEXTURE\n  uniform sampler2D rimTexture;\n#endif\nuniform vec3 rimColor;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\n\n#ifdef USE_SPHEREADD\n  uniform sampler2D sphereAdd;\n#endif\n\nuniform vec3 emissionColor;\n\nuniform vec3 outlineColor;\nuniform float outlineLightingMix;\n\n#ifdef USE_UVANIMMASKTEXTURE\n  uniform sampler2D uvAnimMaskTexture;\n#endif\n\nuniform float uvAnimOffsetX;\nuniform float uvAnimOffsetY;\nuniform float uvAnimTheta;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n#include <lights_pars_begin>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingGrade;\n  float receiveShadow;\n};\n\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126\n  // See: #21205, #21307, #21299\n  #if THREE_VRM_THREE_REVISION >= 126\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      S = normalize( S );\n      T = normalize( T );\n      vec3 N = normalize( surf_norm );\n\n      #ifdef DOUBLE_SIDED\n\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\n      #else\n\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n      mat3 tsn = mat3( S, T, N );\n      return normalize( tsn * mapN );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == lighting stuff ===========================================================\nfloat getLightIntensity(\n  const in IncidentLight directLight,\n  const in GeometricContext geometry,\n  const in float shadow,\n  const in float shadingGrade\n) {\n  float lightIntensity = dot( geometry.normal, directLight.direction );\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\n  lightIntensity = lightIntensity * shadow;\n  lightIntensity = lightIntensity * shadingGrade;\n  lightIntensity = lightIntensity * 2.0 - 1.0;\n  return shadeToony == 1.0\n    ? step( shadeShift, lightIntensity )\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\n}\n\nvec3 getLighting( const in vec3 lightColor ) {\n  vec3 lighting = lightColor;\n  lighting = mix(\n    lighting,\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\n    lightColorAttenuation\n  );\n\n  #if THREE_VRM_THREE_REVISION < 132\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lighting *= PI;\n    #endif\n  #endif\n\n  return lighting;\n}\n\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float lightIntensity,\n  const in vec3 lighting\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( lightIntensity * lighting ) );\n  #endif\n\n  return lighting * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\n}\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMMASKTEXTURE\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\n    #endif\n\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( color, colorAlpha );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissionColor;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    #if THREE_VRM_THREE_REVISION >= 137\n      vec4 sampledDiffuseColor = texture2D( map, uv );\n      #ifdef DECODE_VIDEO_TEXTURE\n        sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n      #endif\n      diffuseColor *= sampledDiffuseColor;\n    #else\n      // COMPAT: pre-r137\n      diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\n    #endif\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // -- MToon: alpha -----------------------------------------------------------\n  // #include <alphatest_fragment>\n  #ifdef BLENDMODE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef BLENDMODE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  #ifdef OBJECTSPACE_NORMALMAP\n\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = normal * faceDirection;\n\n      #else\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  #elif defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    #ifdef USE_TANGENT\n\n      normal = normalize( vTBN * mapN );\n\n    #else\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n      #else\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\n\n      #endif\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    #if THREE_VRM_THREE_REVISION >= 137\n      totalEmissiveRadiance *= texture2D( emissiveMap, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\n    #endif\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColor;\n  #ifdef USE_SHADETEXTURE\n    #if THREE_VRM_THREE_REVISION >= 137\n      material.shadeColor *= texture2D( shadeTexture, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\n    #endif\n  #endif\n\n  material.shadingGrade = 1.0;\n  #ifdef USE_SHADINGGRADETEXTURE\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\n  #endif\n\n  material.receiveShadow = receiveShadowRate;\n  #ifdef USE_RECEIVESHADOWTEXTURE\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\n  #endif\n\n  // #include <lights_fragment_begin>\n  GeometricContext geometry;\n\n  geometry.position = - vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n  IncidentLight directLight;\n  vec3 lightingSum = vec3( 0.0 );\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float atten, shadow, lightIntensity;\n  vec3 lighting;\n\n  #if ( NUM_POINT_LIGHTS > 0 )\n    PointLight pointLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n      pointLight = pointLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getPointLightInfo( pointLight, geometry, directLight );\n      #else\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 )\n    SpotLight spotLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #else\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 )\n    DirectionalLight directionalLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      directionalLight = directionalLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #else\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  // #if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n  #if THREE_VRM_THREE_REVISION >= 133\n    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  #else\n    irradiance += getLightProbeIrradiance( lightProbe, geometry );\n  #endif\n  #if ( NUM_HEMI_LIGHTS > 0 )\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n      #if THREE_VRM_THREE_REVISION >= 133\n        irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n      #else\n        irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n      #endif\n    }\n    #pragma unroll_loop_end\n  #endif\n  // #endif\n\n  // #include <lights_fragment_maps>\n  #ifdef USE_LIGHTMAP\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n    #if THREE_VRM_THREE_REVISION >= 137\n      vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n    #else\n      // COMPAT: pre-r137\n      vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n    #endif\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lightMapIrradiance *= PI;\n    #endif\n    irradiance += lightMapIrradiance;\n  #endif\n\n  // #include <lights_fragment_end>\n  // RE_IndirectDiffuse here\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Lambert( material.diffuseColor );\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  // The "comment out if you want to PBR absolutely" line\n  #ifndef DEBUG_LITSHADERATE\n    col = min(col, material.diffuseColor);\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\n    gl_FragColor = vec4(\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\n      diffuseColor.a\n    );\n    postCorrection();\n    return;\n  #endif\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: parametric rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\n  #ifdef USE_RIMTEXTURE\n    #if THREE_VRM_THREE_REVISION >= 137\n      rim *= texture2D( rimTexture, uv ).rgb;\n    #else\n      // COMPAT: pre-r137\n      rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\n    #endif\n  #endif\n  col += rim;\n\n  // -- MToon: additive matcap -------------------------------------------------\n  #ifdef USE_SPHEREADD\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      #if THREE_VRM_THREE_REVISION >= 137\n        vec3 matcap = texture2D( sphereAdd, sphereUv ).xyz;\n      #else\n        // COMPAT: pre-r137\n        vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\n      #endif\n      col += matcap;\n    }\n  #endif\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}';const pe=3002;const me=3004;const ge=3005;const _e=3006;const ve=3007;const Me=e=>{if(parseInt(v.REVISION,10)>=136){switch(e){case v.LinearEncoding:return["Linear","( value )"];case v.sRGBEncoding:return["sRGB","( value )"];default:console.warn("THREE.WebGLProgram: Unsupported encoding:",e);return["Linear","( value )"]}}else{switch(e){case v.LinearEncoding:return["Linear","( value )"];case v.sRGBEncoding:return["sRGB","( value )"];case pe:return["RGBE","( value )"];case me:return["RGBM","( value, 7.0 )"];case ge:return["RGBM","( value, 16.0 )"];case _e:return["RGBD","( value, 256.0 )"];case ve:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw new Error("unsupported encoding: "+e)}}};const y=(e,n)=>{const t=Me(n);return"vec4 "+e+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"};const Te=2*Math.PI;u.MToonMaterialCullMode=void 0;(function(e){e[e["Off"]=0]="Off";e[e["Front"]=1]="Front";e[e["Back"]=2]="Back"})(u.MToonMaterialCullMode||(u.MToonMaterialCullMode={}));u.MToonMaterialDebugMode=void 0;(function(e){e[e["None"]=0]="None";e[e["Normal"]=1]="Normal";e[e["LitShadeRate"]=2]="LitShadeRate";e[e["UV"]=3]="UV"})(u.MToonMaterialDebugMode||(u.MToonMaterialDebugMode={}));u.MToonMaterialOutlineColorMode=void 0;(function(e){e[e["FixedColor"]=0]="FixedColor";e[e["MixedLighting"]=1]="MixedLighting"})(u.MToonMaterialOutlineColorMode||(u.MToonMaterialOutlineColorMode={}));u.MToonMaterialOutlineWidthMode=void 0;(function(e){e[e["None"]=0]="None";e[e["WorldCoordinates"]=1]="WorldCoordinates";e[e["ScreenCoordinates"]=2]="ScreenCoordinates"})(u.MToonMaterialOutlineWidthMode||(u.MToonMaterialOutlineWidthMode={}));u.MToonMaterialRenderMode=void 0;(function(e){e[e["Opaque"]=0]="Opaque";e[e["Cutout"]=1]="Cutout";e[e["Transparent"]=2]="Transparent";e[e["TransparentWithZWrite"]=3]="TransparentWithZWrite"})(u.MToonMaterialRenderMode||(u.MToonMaterialRenderMode={}));class x extends v.ShaderMaterial{constructor(n={}){super();this.isMToonMaterial=true;this.cutoff=.5;this.color=new v.Vector4(1,1,1,1);this.shadeColor=new v.Vector4(.97,.81,.86,1);this.map=null;this.mainTex_ST=new v.Vector4(0,0,1,1);this.shadeTexture=null;this.normalMap=null;this.normalMapType=v.TangentSpaceNormalMap;this.normalScale=new v.Vector2(1,1);this.receiveShadowRate=1;this.receiveShadowTexture=null;this.shadingGradeRate=1;this.shadingGradeTexture=null;this.shadeShift=0;this.shadeToony=.9;this.lightColorAttenuation=0;this.indirectLightIntensity=.1;this.rimTexture=null;this.rimColor=new v.Vector4(0,0,0,1);this.rimLightingMix=0;this.rimFresnelPower=1;this.rimLift=0;this.sphereAdd=null;this.emissionColor=new v.Vector4(0,0,0,1);this.emissiveMap=null;this.outlineWidthTexture=null;this.outlineWidth=.5;this.outlineScaledMaxDistance=1;this.outlineColor=new v.Vector4(0,0,0,1);this.outlineLightingMix=1;this.uvAnimMaskTexture=null;this.uvAnimScrollX=0;this.uvAnimScrollY=0;this.uvAnimRotation=0;this.shouldApplyUniforms=true;this._debugMode=u.MToonMaterialDebugMode.None;this._blendMode=u.MToonMaterialRenderMode.Opaque;this._outlineWidthMode=u.MToonMaterialOutlineWidthMode.None;this._outlineColorMode=u.MToonMaterialOutlineColorMode.FixedColor;this._cullMode=u.MToonMaterialCullMode.Back;this._outlineCullMode=u.MToonMaterialCullMode.Front;this._isOutline=false;this._uvAnimOffsetX=0;this._uvAnimOffsetY=0;this._uvAnimPhase=0;this.encoding=n.encoding||v.LinearEncoding;if(this.encoding!==v.LinearEncoding&&this.encoding!==v.sRGBEncoding){console.warn("The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead.")}["mToonVersion","shadeTexture_ST","bumpMap_ST","receiveShadowTexture_ST","shadingGradeTexture_ST","rimTexture_ST","sphereAdd_ST","emissionMap_ST","outlineWidthTexture_ST","uvAnimMaskTexture_ST","srcBlend","dstBlend"].forEach(e=>{if(n[e]!==undefined){delete n[e]}});n.fog=true;n.lights=true;n.clipping=true;if(parseInt(v.REVISION,10)<129){n.skinning=n.skinning||false}if(parseInt(v.REVISION,10)<131){n.morphTargets=n.morphTargets||false;n.morphNormals=n.morphNormals||false}n.uniforms=v.UniformsUtils.merge([v.UniformsLib.common,v.UniformsLib.normalmap,v.UniformsLib.emissivemap,v.UniformsLib.fog,v.UniformsLib.lights,{cutoff:{value:.5},color:{value:new v.Color(1,1,1)},colorAlpha:{value:1},shadeColor:{value:new v.Color(.97,.81,.86)},mainTex_ST:{value:new v.Vector4(0,0,1,1)},shadeTexture:{value:null},receiveShadowRate:{value:1},receiveShadowTexture:{value:null},shadingGradeRate:{value:1},shadingGradeTexture:{value:null},shadeShift:{value:0},shadeToony:{value:.9},lightColorAttenuation:{value:0},indirectLightIntensity:{value:.1},rimTexture:{value:null},rimColor:{value:new v.Color(0,0,0)},rimLightingMix:{value:0},rimFresnelPower:{value:1},rimLift:{value:0},sphereAdd:{value:null},emissionColor:{value:new v.Color(0,0,0)},outlineWidthTexture:{value:null},outlineWidth:{value:.5},outlineScaledMaxDistance:{value:1},outlineColor:{value:new v.Color(0,0,0)},outlineLightingMix:{value:1},uvAnimMaskTexture:{value:null},uvAnimOffsetX:{value:0},uvAnimOffsetY:{value:0},uvAnimTheta:{value:0}}]);this.setValues(n);this._updateShaderCode();this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get bumpMap(){return this.normalMap}set bumpMap(e){this.normalMap=e}get bumpScale(){return this.normalScale.x}set bumpScale(e){this.normalScale.set(e,e)}get emissionMap(){return this.emissiveMap}set emissionMap(e){this.emissiveMap=e}get blendMode(){return this._blendMode}set blendMode(e){this._blendMode=e;this.depthWrite=this._blendMode!==u.MToonMaterialRenderMode.Transparent;this.transparent=this._blendMode===u.MToonMaterialRenderMode.Transparent||this._blendMode===u.MToonMaterialRenderMode.TransparentWithZWrite;this._updateShaderCode()}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode=e;this._updateShaderCode()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e;this._updateShaderCode()}get outlineColorMode(){return this._outlineColorMode}set outlineColorMode(e){this._outlineColorMode=e;this._updateShaderCode()}get cullMode(){return this._cullMode}set cullMode(e){this._cullMode=e;this._updateCullFace()}get outlineCullMode(){return this._outlineCullMode}set outlineCullMode(e){this._outlineCullMode=e;this._updateCullFace()}get zWrite(){return this.depthWrite?1:0}set zWrite(e){this.depthWrite=.5<=e}get isOutline(){return this._isOutline}set isOutline(e){this._isOutline=e;this._updateShaderCode();this._updateCullFace()}updateVRMMaterials(e){this._uvAnimOffsetX=this._uvAnimOffsetX+e*this.uvAnimScrollX;this._uvAnimOffsetY=this._uvAnimOffsetY-e*this.uvAnimScrollY;this._uvAnimPhase=this._uvAnimPhase+e*this.uvAnimRotation;this._applyUniforms()}copy(e){super.copy(e);this.cutoff=e.cutoff;this.color.copy(e.color);this.shadeColor.copy(e.shadeColor);this.map=e.map;this.mainTex_ST.copy(e.mainTex_ST);this.shadeTexture=e.shadeTexture;this.normalMap=e.normalMap;this.normalMapType=e.normalMapType;this.normalScale.copy(this.normalScale);this.receiveShadowRate=e.receiveShadowRate;this.receiveShadowTexture=e.receiveShadowTexture;this.shadingGradeRate=e.shadingGradeRate;this.shadingGradeTexture=e.shadingGradeTexture;this.shadeShift=e.shadeShift;this.shadeToony=e.shadeToony;this.lightColorAttenuation=e.lightColorAttenuation;this.indirectLightIntensity=e.indirectLightIntensity;this.rimTexture=e.rimTexture;this.rimColor.copy(e.rimColor);this.rimLightingMix=e.rimLightingMix;this.rimFresnelPower=e.rimFresnelPower;this.rimLift=e.rimLift;this.sphereAdd=e.sphereAdd;this.emissionColor.copy(e.emissionColor);this.emissiveMap=e.emissiveMap;this.outlineWidthTexture=e.outlineWidthTexture;this.outlineWidth=e.outlineWidth;this.outlineScaledMaxDistance=e.outlineScaledMaxDistance;this.outlineColor.copy(e.outlineColor);this.outlineLightingMix=e.outlineLightingMix;this.uvAnimMaskTexture=e.uvAnimMaskTexture;this.uvAnimScrollX=e.uvAnimScrollX;this.uvAnimScrollY=e.uvAnimScrollY;this.uvAnimRotation=e.uvAnimRotation;this.debugMode=e.debugMode;this.blendMode=e.blendMode;this.outlineWidthMode=e.outlineWidthMode;this.outlineColorMode=e.outlineColorMode;this.cullMode=e.cullMode;this.outlineCullMode=e.outlineCullMode;this.isOutline=e.isOutline;return this}_applyUniforms(){this.uniforms.uvAnimOffsetX.value=this._uvAnimOffsetX;this.uniforms.uvAnimOffsetY.value=this._uvAnimOffsetY;this.uniforms.uvAnimTheta.value=Te*this._uvAnimPhase;if(!this.shouldApplyUniforms){return}this.shouldApplyUniforms=false;this.uniforms.cutoff.value=this.cutoff;this.uniforms.color.value.setRGB(this.color.x,this.color.y,this.color.z);this.uniforms.colorAlpha.value=this.color.w;this.uniforms.shadeColor.value.setRGB(this.shadeColor.x,this.shadeColor.y,this.shadeColor.z);this.uniforms.map.value=this.map;this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);this.uniforms.shadeTexture.value=this.shadeTexture;this.uniforms.normalMap.value=this.normalMap;this.uniforms.normalScale.value.copy(this.normalScale);this.uniforms.receiveShadowRate.value=this.receiveShadowRate;this.uniforms.receiveShadowTexture.value=this.receiveShadowTexture;this.uniforms.shadingGradeRate.value=this.shadingGradeRate;this.uniforms.shadingGradeTexture.value=this.shadingGradeTexture;this.uniforms.shadeShift.value=this.shadeShift;this.uniforms.shadeToony.value=this.shadeToony;this.uniforms.lightColorAttenuation.value=this.lightColorAttenuation;this.uniforms.indirectLightIntensity.value=this.indirectLightIntensity;this.uniforms.rimTexture.value=this.rimTexture;this.uniforms.rimColor.value.setRGB(this.rimColor.x,this.rimColor.y,this.rimColor.z);this.uniforms.rimLightingMix.value=this.rimLightingMix;this.uniforms.rimFresnelPower.value=this.rimFresnelPower;this.uniforms.rimLift.value=this.rimLift;this.uniforms.sphereAdd.value=this.sphereAdd;this.uniforms.emissionColor.value.setRGB(this.emissionColor.x,this.emissionColor.y,this.emissionColor.z);this.uniforms.emissiveMap.value=this.emissiveMap;this.uniforms.outlineWidthTexture.value=this.outlineWidthTexture;this.uniforms.outlineWidth.value=this.outlineWidth;this.uniforms.outlineScaledMaxDistance.value=this.outlineScaledMaxDistance;this.uniforms.outlineColor.value.setRGB(this.outlineColor.x,this.outlineColor.y,this.outlineColor.z);this.uniforms.outlineLightingMix.value=this.outlineLightingMix;this.uniforms.uvAnimMaskTexture.value=this.uvAnimMaskTexture;if(this.encoding===v.sRGBEncoding){this.uniforms.color.value.convertSRGBToLinear();this.uniforms.shadeColor.value.convertSRGBToLinear();this.uniforms.rimColor.value.convertSRGBToLinear();this.uniforms.emissionColor.value.convertSRGBToLinear();this.uniforms.outlineColor.value.convertSRGBToLinear()}this._updateCullFace()}_updateShaderCode(){const e=this.outlineWidthTexture!==null;const n=this.map!==null||this.shadeTexture!==null||this.receiveShadowTexture!==null||this.shadingGradeTexture!==null||this.rimTexture!==null||this.uvAnimMaskTexture!==null;this.defines={THREE_VRM_THREE_REVISION:parseInt(v.REVISION,10),OUTLINE:this._isOutline,BLENDMODE_OPAQUE:this._blendMode===u.MToonMaterialRenderMode.Opaque,BLENDMODE_CUTOUT:this._blendMode===u.MToonMaterialRenderMode.Cutout,BLENDMODE_TRANSPARENT:this._blendMode===u.MToonMaterialRenderMode.Transparent||this._blendMode===u.MToonMaterialRenderMode.TransparentWithZWrite,MTOON_USE_UV:e||n,MTOON_UVS_VERTEX_ONLY:e&&!n,USE_SHADETEXTURE:this.shadeTexture!==null,USE_RECEIVESHADOWTEXTURE:this.receiveShadowTexture!==null,USE_SHADINGGRADETEXTURE:this.shadingGradeTexture!==null,USE_RIMTEXTURE:this.rimTexture!==null,USE_SPHEREADD:this.sphereAdd!==null,USE_OUTLINEWIDTHTEXTURE:this.outlineWidthTexture!==null,USE_UVANIMMASKTEXTURE:this.uvAnimMaskTexture!==null,DEBUG_NORMAL:this._debugMode===u.MToonMaterialDebugMode.Normal,DEBUG_LITSHADERATE:this._debugMode===u.MToonMaterialDebugMode.LitShadeRate,DEBUG_UV:this._debugMode===u.MToonMaterialDebugMode.UV,OUTLINE_WIDTH_WORLD:this._outlineWidthMode===u.MToonMaterialOutlineWidthMode.WorldCoordinates,OUTLINE_WIDTH_SCREEN:this._outlineWidthMode===u.MToonMaterialOutlineWidthMode.ScreenCoordinates,OUTLINE_COLOR_FIXED:this._outlineColorMode===u.MToonMaterialOutlineColorMode.FixedColor,OUTLINE_COLOR_MIXED:this._outlineColorMode===u.MToonMaterialOutlineColorMode.MixedLighting};this.vertexShader=ce;this.fragmentShader=fe;if(parseInt(v.REVISION,10)<137){const t=(this.shadeTexture!==null?y("shadeTextureTexelToLinear",this.shadeTexture.encoding)+"\n":"")+(this.sphereAdd!==null?y("sphereAddTexelToLinear",this.sphereAdd.encoding)+"\n":"")+(this.rimTexture!==null?y("rimTextureTexelToLinear",this.rimTexture.encoding)+"\n":"");this.fragmentShader=t+fe}this.needsUpdate=true}_updateCullFace(){if(!this.isOutline){if(this.cullMode===u.MToonMaterialCullMode.Off){this.side=v.DoubleSide}else if(this.cullMode===u.MToonMaterialCullMode.Front){this.side=v.BackSide}else if(this.cullMode===u.MToonMaterialCullMode.Back){this.side=v.FrontSide}}else{if(this.outlineCullMode===u.MToonMaterialCullMode.Off){this.side=v.DoubleSide}else if(this.outlineCullMode===u.MToonMaterialCullMode.Front){this.side=v.BackSide}else if(this.outlineCullMode===u.MToonMaterialCullMode.Back){this.side=v.FrontSide}}}}var ye="#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef USE_MAP\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n  #include <skinbase_vertex>\n\n  #ifdef USE_ENVMAP\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n\n  #endif\n\n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n\n  #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n  #include <envmap_vertex>\n  #include <fog_vertex>\n\n}";var xe="#ifdef RENDERTYPE_CUTOUT\n  uniform float cutoff;\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n// #include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n// #include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4( 1.0 );\n\n  #include <logdepthbuf_fragment>\n\n  #include <map_fragment>\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // MToon: alpha\n  // #include <alphatest_fragment>\n  #ifdef RENDERTYPE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef RENDERTYPE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  // #include <specularmap_fragment>\n\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n  // accumulation (baked indirect lighting only)\n  #ifdef USE_LIGHTMAP\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  #else\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\n  #endif\n\n  // modulation\n  // #include <aomap_fragment>\n\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n  // #include <envmap_fragment>\n\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}";u.VRMUnlitMaterialRenderType=void 0;(function(e){e[e["Opaque"]=0]="Opaque";e[e["Cutout"]=1]="Cutout";e[e["Transparent"]=2]="Transparent";e[e["TransparentWithZWrite"]=3]="TransparentWithZWrite"})(u.VRMUnlitMaterialRenderType||(u.VRMUnlitMaterialRenderType={}));class S extends v.ShaderMaterial{constructor(e){super();this.isVRMUnlitMaterial=true;this.cutoff=.5;this.map=null;this.mainTex_ST=new v.Vector4(0,0,1,1);this._renderType=u.VRMUnlitMaterialRenderType.Opaque;this.shouldApplyUniforms=true;if(e===undefined){e={}}e.fog=true;e.clipping=true;if(parseInt(v.REVISION,10)<129){e.skinning=e.skinning||false}if(parseInt(v.REVISION,10)<131){e.morphTargets=e.morphTargets||false;e.morphNormals=e.morphNormals||false}e.uniforms=v.UniformsUtils.merge([v.UniformsLib.common,v.UniformsLib.fog,{cutoff:{value:.5},mainTex_ST:{value:new v.Vector4(0,0,1,1)}}]);this.setValues(e);this._updateShaderCode();this._applyUniforms()}get mainTex(){return this.map}set mainTex(e){this.map=e}get renderType(){return this._renderType}set renderType(e){this._renderType=e;this.depthWrite=this._renderType!==u.VRMUnlitMaterialRenderType.Transparent;this.transparent=this._renderType===u.VRMUnlitMaterialRenderType.Transparent||this._renderType===u.VRMUnlitMaterialRenderType.TransparentWithZWrite;this._updateShaderCode()}updateVRMMaterials(e){this._applyUniforms()}copy(e){super.copy(e);this.cutoff=e.cutoff;this.map=e.map;this.mainTex_ST.copy(e.mainTex_ST);this.renderType=e.renderType;return this}_applyUniforms(){if(!this.shouldApplyUniforms){return}this.shouldApplyUniforms=false;this.uniforms.cutoff.value=this.cutoff;this.uniforms.map.value=this.map;this.uniforms.mainTex_ST.value.copy(this.mainTex_ST)}_updateShaderCode(){this.defines={RENDERTYPE_OPAQUE:this._renderType===u.VRMUnlitMaterialRenderType.Opaque,RENDERTYPE_CUTOUT:this._renderType===u.VRMUnlitMaterialRenderType.Cutout,RENDERTYPE_TRANSPARENT:this._renderType===u.VRMUnlitMaterialRenderType.Transparent||this._renderType===u.VRMUnlitMaterialRenderType.TransparentWithZWrite};this.vertexShader=ye;this.fragmentShader=xe;this.needsUpdate=true}}class Se{constructor(e={}){this._encoding=e.encoding||v.LinearEncoding;if(this._encoding!==v.LinearEncoding&&this._encoding!==v.sRGBEncoding){console.warn("The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead.")}this._requestEnvMap=e.requestEnvMap}convertGLTFMaterials(c){var t;return f(this,void 0,void 0,function*(){const e=(t=c.parser.json.extensions)===null||t===void 0?void 0:t.VRM;if(!e){return null}const d=e.materialProperties;if(!d){return null}const n=yield p(c);const u={};const h=[];yield Promise.all(Array.from(n.entries()).map(([n,t])=>f(this,void 0,void 0,function*(){const e=c.parser.json.nodes[n];const l=c.parser.json.meshes[e.mesh];yield Promise.all(t.map((s,a)=>f(this,void 0,void 0,function*(){const e=l.primitives[a];if(!e){return}const n=s.geometry;const t=n.index?n.index.count:n.attributes.position.count/3;if(!Array.isArray(s.material)){s.material=[s.material];n.addGroup(0,t,0)}const i=e.material;let r=d[i];if(!r){console.warn(`VRMMaterialImporter: There are no material definition for material #${i} on VRM extension.`);r={shader:"VRM_USE_GLTFSHADER"}}let o;if(u[i]){o=u[i]}else{o=yield this.createVRMMaterials(s.material[0],r,c);u[i]=o;h.push(o.surface);if(o.outline){h.push(o.outline)}}s.material[0]=o.surface;if(this._requestEnvMap&&o.surface.isMeshStandardMaterial){this._requestEnvMap().then(e=>{o.surface.envMap=e;o.surface.needsUpdate=true})}s.renderOrder=r.renderQueue||2e3;if(o.outline){s.material[1]=o.outline;n.addGroup(0,t,1)}})))})));return h})}createVRMMaterials(i,r,o){return f(this,void 0,void 0,function*(){let e;let n;if(r.shader==="VRM/MToon"){const t=yield this._extractMaterialProperties(i,r,o);["srcBlend","dstBlend","isFirstSetup"].forEach(e=>{if(t[e]!==undefined){delete t[e]}});["mainTex","shadeTexture","emissionMap","sphereAdd","rimTexture"].forEach(e=>{if(t[e]!==undefined){t[e].encoding=this._encoding}});t.encoding=this._encoding;e=new x(t);if(t.outlineWidthMode!==u.MToonMaterialOutlineWidthMode.None){t.isOutline=true;n=new x(t)}}else if(r.shader==="VRM/UnlitTexture"){const t=yield this._extractMaterialProperties(i,r,o);t.renderType=u.VRMUnlitMaterialRenderType.Opaque;e=new S(t)}else if(r.shader==="VRM/UnlitCutout"){const t=yield this._extractMaterialProperties(i,r,o);t.renderType=u.VRMUnlitMaterialRenderType.Cutout;e=new S(t)}else if(r.shader==="VRM/UnlitTransparent"){const t=yield this._extractMaterialProperties(i,r,o);t.renderType=u.VRMUnlitMaterialRenderType.Transparent;e=new S(t)}else if(r.shader==="VRM/UnlitTransparentZWrite"){const t=yield this._extractMaterialProperties(i,r,o);t.renderType=u.VRMUnlitMaterialRenderType.TransparentWithZWrite;e=new S(t)}else{if(r.shader!=="VRM_USE_GLTFSHADER"){console.warn(`Unknown shader detected: "${r.shader}"`)}e=this._convertGLTFMaterial(i.clone())}e.name=i.name;e.userData=JSON.parse(JSON.stringify(i.userData));e.userData.vrmMaterialProperties=r;if(n){n.name=i.name+" (Outline)";n.userData=JSON.parse(JSON.stringify(i.userData));n.userData.vrmMaterialProperties=r}return{surface:e,outline:n}})}_renameMaterialProperty(e){if(e[0]!=="_"){console.warn(`VRMMaterials: Given property name "${e}" might be invalid`);return e}e=e.substring(1);if(!/[A-Z]/.test(e[0])){console.warn(`VRMMaterials: Given property name "${e}" might be invalid`);return e}return e[0].toLowerCase()+e.substring(1)}_convertGLTFMaterial(e){if(e.isMeshStandardMaterial){const n=e;if(n.map){n.map.encoding=this._encoding}if(n.emissiveMap){n.emissiveMap.encoding=this._encoding}if(this._encoding===v.LinearEncoding){n.color.convertLinearToSRGB();n.emissive.convertLinearToSRGB()}}if(e.isMeshBasicMaterial){const n=e;if(n.map){n.map.encoding=this._encoding}if(this._encoding===v.LinearEncoding){n.color.convertLinearToSRGB()}}return e}_extractMaterialProperties(e,n,t){const i=[];const r={};if(n.textureProperties){for(const o of Object.keys(n.textureProperties)){const s=this._renameMaterialProperty(o);const a=n.textureProperties[o];i.push(t.parser.getDependency("texture",a).then(e=>{r[s]=e}))}}if(n.floatProperties){for(const o of Object.keys(n.floatProperties)){const s=this._renameMaterialProperty(o);r[s]=n.floatProperties[o]}}if(n.vectorProperties){for(const o of Object.keys(n.vectorProperties)){let e=this._renameMaterialProperty(o);const l=["_MainTex","_ShadeTexture","_BumpMap","_ReceiveShadowTexture","_ShadingGradeTexture","_RimTexture","_SphereAdd","_EmissionMap","_OutlineWidthTexture","_UvAnimMaskTexture"].some(e=>o===e);if(l){e+="_ST"}r[e]=new v.Vector4(...n.vectorProperties[o])}}if(parseInt(v.REVISION,10)<129){r.skinning=e.skinning||false}if(parseInt(v.REVISION,10)<131){r.morphTargets=e.morphTargets||false;r.morphNormals=e.morphNormals||false}return Promise.all(i).then(()=>r)}}class Re{constructor(e){var n;this.ignoreTexture=(n=e===null||e===void 0?void 0:e.ignoreTexture)!==null&&n!==void 0?n:false}"import"(i){var r;return f(this,void 0,void 0,function*(){const e=(r=i.parser.json.extensions)===null||r===void 0?void 0:r.VRM;if(!e){return null}const n=e.meta;if(!n){return null}let t;if(!this.ignoreTexture&&n.texture!=null&&n.texture!==-1){t=yield i.parser.getDependency("texture",n.texture)}return{allowedUserName:n.allowedUserName,author:n.author,commercialUssageName:n.commercialUssageName,contactInformation:n.contactInformation,licenseName:n.licenseName,otherLicenseUrl:n.otherLicenseUrl,otherPermissionUrl:n.otherPermissionUrl,reference:n.reference,sexualUssageName:n.sexualUssageName,texture:t!==null&&t!==void 0?t:undefined,title:n.title,version:n.version,violentUssageName:n.violentUssageName}})}}const Ee=new v.Matrix4;function Le(e){if(e.invert){e.invert()}else{e.getInverse(Ee.copy(e))}return e}class we{constructor(e){this._inverseCache=new v.Matrix4;this._shouldUpdateInverse=true;this.matrix=e;const n={set:(e,n,t)=>{this._shouldUpdateInverse=true;e[n]=t;return true}};this._originalElements=e.elements;e.elements=new Proxy(e.elements,n)}get inverse(){if(this._shouldUpdateInverse){Le(this._inverseCache.copy(this.matrix));this._shouldUpdateInverse=false}return this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const Pe=Object.freeze(new v.Matrix4);const Ae=Object.freeze(new v.Quaternion);const R=new v.Vector3;const be=new v.Vector3;const Oe=new v.Vector3;const Ce=new v.Quaternion;const E=new v.Matrix4;const L=new v.Matrix4;class w{constructor(e,n={}){var t,i,r,o,s,a;this._currentTail=new v.Vector3;this._prevTail=new v.Vector3;this._nextTail=new v.Vector3;this._boneAxis=new v.Vector3;this._centerSpacePosition=new v.Vector3;this._center=null;this._parentWorldRotation=new v.Quaternion;this._initialLocalMatrix=new v.Matrix4;this._initialLocalRotation=new v.Quaternion;this._initialLocalChildPosition=new v.Vector3;this.bone=e;this.bone.matrixAutoUpdate=false;this.radius=(t=n.radius)!==null&&t!==void 0?t:.02;this.stiffnessForce=(i=n.stiffnessForce)!==null&&i!==void 0?i:1;this.gravityDir=n.gravityDir?(new v.Vector3).copy(n.gravityDir):(new v.Vector3).set(0,-1,0);this.gravityPower=(r=n.gravityPower)!==null&&r!==void 0?r:0;this.dragForce=(o=n.dragForce)!==null&&o!==void 0?o:.4;this.colliders=(s=n.colliders)!==null&&s!==void 0?s:[];this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld);this._initialLocalMatrix.copy(this.bone.matrix);this._initialLocalRotation.copy(this.bone.quaternion);if(this.bone.children.length===0){this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07)}else{const l=this.bone.children[0];this._initialLocalChildPosition.copy(l.position)}this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));this._prevTail.copy(this._currentTail);this._nextTail.copy(this._currentTail);this._boneAxis.copy(this._initialLocalChildPosition).normalize();this._centerSpaceBoneLength=R.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length();this.center=(a=n.center)!==null&&a!==void 0?a:null}get center(){return this._center}set center(e){var n;this._getMatrixCenterToWorld(E);this._currentTail.applyMatrix4(E);this._prevTail.applyMatrix4(E);this._nextTail.applyMatrix4(E);if((n=this._center)===null||n===void 0?void 0:n.userData.inverseCacheProxy){this._center.userData.inverseCacheProxy.revert();delete this._center.userData.inverseCacheProxy}this._center=e;if(this._center){if(!this._center.userData.inverseCacheProxy){this._center.userData.inverseCacheProxy=new we(this._center.matrixWorld)}}this._getMatrixWorldToCenter(E);this._currentTail.applyMatrix4(E);this._prevTail.applyMatrix4(E);this._nextTail.applyMatrix4(E);E.multiply(this.bone.matrixWorld);this._centerSpacePosition.setFromMatrixPosition(E);this._centerSpaceBoneLength=R.copy(this._initialLocalChildPosition).applyMatrix4(E).sub(this._centerSpacePosition).length()}reset(){this.bone.quaternion.copy(this._initialLocalRotation);this.bone.updateMatrix();this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix);this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld);this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));this._prevTail.copy(this._currentTail);this._nextTail.copy(this._currentTail)}update(e){if(e<=0)return;if(this.bone.parent){s(this.bone.parent,this._parentWorldRotation)}else{this._parentWorldRotation.copy(Ae)}this._getMatrixWorldToCenter(E);E.multiply(this.bone.matrixWorld);this._centerSpacePosition.setFromMatrixPosition(E);this._getMatrixWorldToCenter(L);L.multiply(this._getParentMatrixWorld());const n=this.stiffnessForce*e;const t=be.copy(this.gravityDir).multiplyScalar(this.gravityPower*e);this._nextTail.copy(this._currentTail).add(R.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1-this.dragForce)).add(R.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(L).sub(this._centerSpacePosition).normalize().multiplyScalar(n)).add(t);this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition);this._collision(this._nextTail);this._prevTail.copy(this._currentTail);this._currentTail.copy(this._nextTail);const i=Le(E.copy(L.multiply(this._initialLocalMatrix)));const r=Ce.setFromUnitVectors(this._boneAxis,R.copy(this._nextTail).applyMatrix4(i).normalize());this.bone.quaternion.copy(this._initialLocalRotation).multiply(r);this.bone.updateMatrix();this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix)}_collision(s){this.colliders.forEach(e=>{this._getMatrixWorldToCenter(E);E.multiply(e.matrixWorld);const n=R.setFromMatrixPosition(E);const t=e.geometry.boundingSphere.radius;const i=this.radius+t;if(s.distanceToSquared(n)<=i*i){const r=be.subVectors(s,n).normalize();const o=Oe.addVectors(n,r.multiplyScalar(i));s.copy(o.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition))}})}_getMatrixCenterToWorld(e){if(this._center){e.copy(this._center.matrixWorld)}else{e.identity()}return e}_getMatrixWorldToCenter(e){if(this._center){e.copy(this._center.userData.inverseCacheProxy.inverse)}else{e.identity()}return e}_getParentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:Pe}}class P{constructor(e,n){this.colliderGroups=[];this.springBoneGroupList=[];this.colliderGroups=e;this.springBoneGroupList=n}setCenter(n){this.springBoneGroupList.forEach(e=>{e.forEach(e=>{e.center=n})})}lateUpdate(n){const t=new Set;this.springBoneGroupList.forEach(e=>{e.forEach(e=>{this._updateWorldMatrix(t,e.bone);e.update(n)})})}reset(){const n=new Set;this.springBoneGroupList.forEach(e=>{e.forEach(e=>{this._updateWorldMatrix(n,e.bone);e.reset()})})}_updateWorldMatrix(e,n){if(e.has(n))return;if(n.parent)this._updateWorldMatrix(e,n.parent);n.updateWorldMatrix(false,false);e.add(n)}}const Ie=new v.Vector3;const Ve=new v.MeshBasicMaterial({visible:false});class A{"import"(r){var o;return f(this,void 0,void 0,function*(){const e=(o=r.parser.json.extensions)===null||o===void 0?void 0:o.VRM;if(!e)return null;const n=e.secondaryAnimation;if(!n)return null;const t=yield this._importColliderMeshGroups(r,n);const i=yield this._importSpringBoneGroupList(r,n,t);return new P(t,i)})}_createSpringBone(e,n={}){return new w(e,n)}_importSpringBoneGroupList(h,t,c){return f(this,void 0,void 0,function*(){const e=t.boneGroups||[];const n=[];yield Promise.all(e.map(u=>f(this,void 0,void 0,function*(){if(u.stiffiness===undefined||u.gravityDir===undefined||u.gravityDir.x===undefined||u.gravityDir.y===undefined||u.gravityDir.z===undefined||u.gravityPower===undefined||u.dragForce===undefined||u.hitRadius===undefined||u.colliderGroups===undefined||u.bones===undefined||u.center===undefined){return}const i=u.stiffiness;const r=new v.Vector3(u.gravityDir.x,u.gravityDir.y,-u.gravityDir.z);const o=u.gravityPower;const s=u.dragForce;const a=u.hitRadius;const l=[];u.colliderGroups.forEach(e=>{l.push(...c[e].colliders)});const d=[];yield Promise.all(u.bones.map(n=>f(this,void 0,void 0,function*(){const e=yield h.parser.getDependency("node",n);const t=u.center!==-1?yield h.parser.getDependency("node",u.center):null;if(!e){return}e.traverse(e=>{const n=this._createSpringBone(e,{radius:a,stiffnessForce:i,gravityDir:r,gravityPower:o,dragForce:s,colliders:l,center:t});d.push(n)})})));n.push(d)})));return n})}_importColliderMeshGroups(o,n){return f(this,void 0,void 0,function*(){const e=n.colliderGroups;if(e===undefined)return[];const t=[];e.forEach(n=>f(this,void 0,void 0,function*(){if(n.node===undefined||n.colliders===undefined){return}const i=yield o.parser.getDependency("node",n.node);const r=[];n.colliders.forEach(e=>{if(e.offset===undefined||e.offset.x===undefined||e.offset.y===undefined||e.offset.z===undefined||e.radius===undefined){return}const n=Ie.set(e.offset.x,e.offset.y,-e.offset.z);const t=this._createColliderMesh(e.radius,n);i.add(t);r.push(t)});const e={node:n.node,colliders:r};t.push(e)}));return t})}_createColliderMesh(e,n){const t=new v.Mesh(new v.SphereBufferGeometry(e,8,4),Ve);t.position.copy(n);t.name="vrmColliderSphere";t.geometry.computeBoundingSphere();return t}}class b{constructor(e={}){this._metaImporter=e.metaImporter||new Re;this._blendShapeImporter=e.blendShapeImporter||new Q;this._lookAtImporter=e.lookAtImporter||new T;this._humanoidImporter=e.humanoidImporter||new te;this._firstPersonImporter=e.firstPersonImporter||new J;this._materialImporter=e.materialImporter||new Se;this._springBoneImporter=e.springBoneImporter||new A}"import"(l){return f(this,void 0,void 0,function*(){if(l.parser.json.extensions===undefined||l.parser.json.extensions.VRM===undefined){throw new Error("Could not find VRM extension on the GLTF")}const e=l.scene;e.updateMatrixWorld(false);e.traverse(e=>{if(e.isMesh){e.frustumCulled=false}});const n=(yield this._metaImporter["import"](l))||undefined;const t=(yield this._materialImporter.convertGLTFMaterials(l))||undefined;const i=(yield this._humanoidImporter["import"](l))||undefined;const r=i?(yield this._firstPersonImporter["import"](l,i))||undefined:undefined;const o=(yield this._blendShapeImporter["import"](l))||undefined;const s=r&&o&&i?(yield this._lookAtImporter["import"](l,r,o,i))||undefined:undefined;const a=(yield this._springBoneImporter["import"](l))||undefined;return new O({scene:l.scene,meta:n,materials:t,humanoid:i,firstPerson:r,blendShapeProxy:o,lookAt:s,springBoneManager:a})})}}class O{constructor(e){this.scene=e.scene;this.humanoid=e.humanoid;this.blendShapeProxy=e.blendShapeProxy;this.firstPerson=e.firstPerson;this.lookAt=e.lookAt;this.materials=e.materials;this.springBoneManager=e.springBoneManager;this.meta=e.meta}static from(n,t={}){return f(this,void 0,void 0,function*(){const e=new b(t);return yield e["import"](n)})}update(n){if(this.lookAt){this.lookAt.update(n)}if(this.blendShapeProxy){this.blendShapeProxy.update()}if(this.springBoneManager){this.springBoneManager.lateUpdate(n)}if(this.materials){this.materials.forEach(e=>{if(e.updateVRMMaterials){e.updateVRMMaterials(n)}})}}dispose(){var e,n;const t=this.scene;if(t){B(t)}(n=(e=this.meta)===null||e===void 0?void 0:e.texture)===null||n===void 0?void 0:n.dispose()}}const C=new v.Vector2;const De=new v.OrthographicCamera(-1,1,-1,1,-1,1);const I=new v.MeshBasicMaterial({color:16777215,side:v.DoubleSide});const Ne=new v.Mesh(new v.PlaneBufferGeometry(2,2),I);const Ue=new v.Scene;Ue.add(Ne);function Be(i,e,n=512){var t;const r=(t=e.meta)===null||t===void 0?void 0:t.texture;if(!r){throw new Error("extractThumbnailBlob: This VRM does not have a thumbnail")}const o=i.getContext().canvas;i.getSize(C);const s=C.x;const a=C.y;i.setSize(n,n,false);I.map=r;i.render(Ue,De);I.map=null;if(o instanceof OffscreenCanvas){return o.convertToBlob()["finally"](()=>{i.setSize(s,a,false)})}return new Promise((n,t)=>{o.toBlob(e=>{i.setSize(s,a,false);if(e==null){t("extractThumbnailBlob: Failed to create a blob")}else{n(e)}})})}function Ge(e){const u=new Map;e.traverse(e=>{if(e.type!=="SkinnedMesh"){return}const n=e;const t=n.geometry;const i=t.getAttribute("skinIndex");let r=u.get(i);if(!r){const o=[];const s=[];const a={};const l=i.array;for(let e=0;e<l.length;e++){const d=l[e];if(a[d]===undefined){a[d]=o.length;o.push(n.skeleton.bones[d]);s.push(n.skeleton.boneInverses[d])}l[e]=a[d]}i.copyArray(l);i.needsUpdate=true;r=new v.Skeleton(o,s);u.set(i,r)}n.bind(r,new v.Matrix4)})}function He(e){const g=new Map;e.traverse(e=>{var n,t,i,r;if(!e.isMesh){return}const o=e;const l=o.geometry;const s=l.index;if(s==null){return}const a=g.get(l);if(a!=null){o.geometry=a;return}const d=new v.BufferGeometry;d.name=l.name;d.morphTargetsRelative=l.morphTargetsRelative;l.groups.forEach(e=>{d.addGroup(e.start,e.count,e.materialIndex)});d.boundingBox=(t=(n=l.boundingBox)===null||n===void 0?void 0:n.clone())!==null&&t!==void 0?t:null;d.boundingSphere=(r=(i=l.boundingSphere)===null||i===void 0?void 0:i.clone())!==null&&r!==void 0?r:null;d.setDrawRange(l.drawRange.start,l.drawRange.count);d.userData=l.userData;g.set(l,d);const u=[];const h=[];{const f=s.array;const p=new f.constructor(f.length);let t=0;for(let n=0;n<f.length;n++){const m=f[n];let e=u[m];if(e==null){u[m]=t;h[t]=m;e=t;t++}p[n]=e}d.setIndex(new _.BufferAttribute(p,1,false))}Object.keys(l.attributes).forEach(e=>{const n=l.attributes[e];if(n.isInterleavedBufferAttribute){throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported")}const i=n.array;const{itemSize:r,normalized:t}=n;const o=new i.constructor(h.length*r);h.forEach((n,t)=>{for(let e=0;e<r;e++){o[t*r+e]=i[n*r+e]}});d.setAttribute(e,new _.BufferAttribute(o,r,t))});let c=true;Object.keys(l.morphAttributes).forEach(n=>{d.morphAttributes[n]=[];const t=l.morphAttributes[n];for(let e=0;e<t.length;e++){const i=t[e];if(i.isInterleavedBufferAttribute){throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported")}const r=i.array;const{itemSize:o,normalized:s}=i;const a=new r.constructor(h.length*o);h.forEach((n,t)=>{for(let e=0;e<o;e++){a[t*o+e]=r[n*o+e]}});c=c&&a.every(e=>e===0);d.morphAttributes[n][e]=new _.BufferAttribute(a,o,s)}});if(c){d.morphAttributes={}}o.geometry=d});Array.from(g.keys()).forEach(e=>{e.dispose()})}class V{constructor(){}}V.extractThumbnailBlob=Be;V.removeUnnecessaryJoints=Ge;V.removeUnnecessaryVertices=He;const ke=new v.Vector3;class Fe extends g{setupHelper(e,n){if(!n.disableFaceDirectionHelper){this._faceDirectionHelper=new v.ArrowHelper(new v.Vector3(0,0,-1),new v.Vector3(0,0,0),.5,16711935);e.add(this._faceDirectionHelper)}}update(e){super.update(e);if(this._faceDirectionHelper){this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position);this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(ke))}}}class We extends T{"import"(e,n,t,i){var r;const o=(r=e.parser.json.extensions)===null||r===void 0?void 0:r.VRM;if(!o){return null}const s=o.firstPerson;if(!s){return null}const a=this._importApplyer(s,t,i);return new Fe(n,a||undefined)}}const ze=new v.MeshBasicMaterial({color:16711935,wireframe:true,transparent:true,depthTest:false});class je extends P{setupHelper(t,e){if(e.disableSpringBoneHelper)return;this.springBoneGroupList.forEach(e=>{e.forEach(e=>{if(e.getGizmo){const n=e.getGizmo();t.add(n)}})});this.colliderGroups.forEach(e=>{e.colliders.forEach(e=>{e.material=ze;e.renderOrder=D})})}}const Ye=new v.Vector3;class Xe extends w{constructor(e,n){super(e,n)}getGizmo(){if(this._gizmo){return this._gizmo}const e=Ye.copy(this._nextTail).sub(this._centerSpacePosition);const n=e.length();this._gizmo=new v.ArrowHelper(e.normalize(),this._centerSpacePosition,n,16776960,this.radius,this.radius);this._gizmo.line.renderOrder=D;this._gizmo.cone.renderOrder=D;this._gizmo.line.material.depthTest=false;this._gizmo.line.material.transparent=true;this._gizmo.cone.material.depthTest=false;this._gizmo.cone.material.transparent=true;return this._gizmo}update(e){super.update(e);this._updateGizmo()}_updateGizmo(){if(!this._gizmo){return}const e=Ye.copy(this._currentTail).sub(this._centerSpacePosition);const n=e.length();this._gizmo.setDirection(e.normalize());this._gizmo.setLength(n,this.radius,this.radius);this._gizmo.position.copy(this._centerSpacePosition)}}class qe extends A{"import"(r){var o;return f(this,void 0,void 0,function*(){const e=(o=r.parser.json.extensions)===null||o===void 0?void 0:o.VRM;if(!e)return null;const n=e.secondaryAnimation;if(!n)return null;const t=yield this._importColliderMeshGroups(r,n);const i=yield this._importSpringBoneGroupList(r,n,t);return new je(t,i)})}_createSpringBone(e,n){return new Xe(e,n)}}class Qe extends b{constructor(e={}){e.lookAtImporter=e.lookAtImporter||new We;e.springBoneImporter=e.springBoneImporter||new qe;super(e)}"import"(l,d={}){return f(this,void 0,void 0,function*(){if(l.parser.json.extensions===undefined||l.parser.json.extensions.VRM===undefined){throw new Error("Could not find VRM extension on the GLTF")}const e=l.scene;e.updateMatrixWorld(false);e.traverse(e=>{if(e.isMesh){e.frustumCulled=false}});const n=(yield this._metaImporter["import"](l))||undefined;const t=(yield this._materialImporter.convertGLTFMaterials(l))||undefined;const i=(yield this._humanoidImporter["import"](l))||undefined;const r=i?(yield this._firstPersonImporter["import"](l,i))||undefined:undefined;const o=(yield this._blendShapeImporter["import"](l))||undefined;const s=r&&o&&i?(yield this._lookAtImporter["import"](l,r,o,i))||undefined:undefined;if(s.setupHelper){s.setupHelper(e,d)}const a=(yield this._springBoneImporter["import"](l))||undefined;if(a.setupHelper){a.setupHelper(e,d)}return new Ze({scene:l.scene,meta:n,materials:t,humanoid:i,firstPerson:r,blendShapeProxy:o,lookAt:s,springBoneManager:a},d)})}}const D=1e4;class Ze extends O{static from(n,t={},i={}){return f(this,void 0,void 0,function*(){const e=new Qe(t);return yield e["import"](n,i)})}constructor(e,n={}){super(e);if(!n.disableBoxHelper){this.scene.add(new v.BoxHelper(this.scene))}if(!n.disableSkeletonHelper){this.scene.add(new v.SkeletonHelper(this.scene))}}update(e){super.update(e)}}u.MToonMaterial=x;u.VRM=O;u.VRMBlendShapeGroup=d;u.VRMBlendShapeImporter=Q;u.VRMBlendShapeProxy=q;u.VRMCurveMapper=n;u.VRMDebug=Ze;u.VRMFirstPerson=c;u.VRMFirstPersonImporter=J;u.VRMHumanBone=K;u.VRMHumanoid=ne;u.VRMHumanoidImporter=te;u.VRMImporter=b;u.VRMLookAtApplyer=e;u.VRMLookAtBlendShapeApplyer=oe;u.VRMLookAtBoneApplyer=he;u.VRMLookAtHead=g;u.VRMLookAtImporter=T;u.VRMMaterialImporter=Se;u.VRMMetaImporter=Re;u.VRMRendererFirstPersonFlags=h;u.VRMSpringBone=w;u.VRMSpringBoneDebug=Xe;u.VRMSpringBoneImporter=A;u.VRMSpringBoneImporterDebug=qe;u.VRMSpringBoneManager=P;u.VRMUnlitMaterial=S;u.VRMUtils=V;u.VRM_GIZMO_RENDER_ORDER=D;Object.defineProperty(u,"__esModule",{value:true});Object.assign(_,u)});